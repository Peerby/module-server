client
=========

module-client
------------

- exposes load function which loads a module and its dependencies in one single HTTP request
- only files that are not yet loaded in the client are requested from the backend


module-compiler
=========

- running closure compiler to minify js, create source maps and dependency graph


server
=========

demo-server
------------

- requires module-server, instantiates it with path to built module graph json file
- when module-server is ready, creates http server
- http server listens for different routes to server js and js maps

module-server
-----------

- requires module-graph, to determine which dependencies should be loaded
- loads requested modules based on module graph
- returns dependencies as concatenated String
- includes optional source map

module-graph
-----------

- interprets closure-compiled dependency graph
- returns delta between required modules and excluded modules and their
  (transitive) dependencies




TODO
==========

- create a demo project that is not generated by test suite: helps figuring out how
  it works in practice (especially on the client), and helps the refactor mentioned
  in the point below.

- to make this project a drop-in solution, parts of demo-server should be included 
  in a library, resulting in two files with different responsibilities:
  - module-server.js: general serving of module-server files, that would be required 
    in each project: js, js maps, module-client.js, LABjs (existing module-server.js
    should be renamed to module-loader.js)
  - demo-server.js: app specific serving of files, demo.html

- serve a minified module-client

- write express integration